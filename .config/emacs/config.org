#+STARTUP: overview
#+TITLE: Miika's Emacs
#+CREATOR: Miika Nissi
#+LANGUAGE: en
#+OPTIONS: num:nil
#+html: <p align="center"><img src="./screenshots/dashboard.png"/></p>
* Installation
=git clone https://github.com/miikanissi/MiikasEmacs ~/.config/emacs=

Make sure to remove your own =~/.emacs=, =~/.emacs.d= and =~/.config/emacs= prior to cloning this configuration. When you launch emacs it will automatically download and setup all packages.
This configuration is written in Org-mode and is self documented. 

** Extra dependencies
*** Fonts
I currently use DejaVu Sans Mono Nerd Font from [[https://github.com/ryanoasis/nerd-fonts][Nerd fonts]]. You need to make sure this font is installed for emacs to use it.
*** From package manager:
- =clang=, for c/c++ completion.
- =python-virtualenv=, for python completion.
- =texlive-core=, for exporting org documents to pdf.
- =texlive-latexextra=, for exporting org documents to pdf.
- =mpd= & =mpc=, for playing music with Mingus.
*** From pip:
For python completion and syntax checking you need to install these from pip:
- =jedi=, for python completion and syntax checking.
- =flake8=, for python completion and syntax checking.
- =autopep8=, for python syntax checking.
- =pylint=, for python syntax checking.
- =pylint-odoo=, for python syntax checking with Odoo.
*** Emacs installation:
On the first launch of Emacs you might need to run some commands using M-x to fully install everything. Here's a list:
- =all-the-icons-install-fonts=
- =jedi:install-server=
* Theme
I don't want my eyes to bleed with the default theme.
** Gruvbox
I don't think Gruvbox is the prettiest theme out there, but it is VERY easy on the eyes and I think that's the most important part.
#+begin_src emacs-lisp
  (use-package gruvbox-theme
    :ensure t
    :init
    (load-theme 'gruvbox-dark-hard t))
#+end_src
* Basic Settings
These are basic default settings that enhance the UI and functionality. No external packages used here.
** UTF-8 encoding everywhere
#+begin_src emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+end_src
** No startup message
I use a replacement for the default startup menu, =dashboard= package.
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src
** Remove menus and scrollbar
I don't use the GUI menus so I get rid of them.
#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src
** Enable clipboard outside of Emacs
#+begin_src emacs-lisp
  (setq x-select-enable-clipboard t)
#+end_src
** Better scrolling behavior
By default emacs scrolling jumps multiple lines when you hit the bottom of the screen. This changes the default behavior to a more sane option.
#+begin_src emacs-lisp
(setq scroll-conservatively 100)
#+end_src
** No ring-bell for errors
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src
** Highlight current line
Very helpful to avoid "losing" your cursor.
#+begin_src emacs-lisp
(when window-system (global-hl-line-mode t))
#+end_src
** Show matching paranthesis
#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src
** Visual line mode
By default long lines will go off the screen, I like to have them wrap on the next line instead. 
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
** No backups
I don't need backup or autosave files so I disable them. By default emacs creates backup files as =filename~= in the files directory. Better behavior would be to have a seperate directory for all backups but I don't feel the need for it.
#+begin_src emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+end_src
** Change yes-or-no to y-or-n
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Subword
By default =M-f= / =M-b= treat thisIsOneWord as a single word instead. I want it to consider capitalization as a new word.
 #+begin_src emacs-lisp
   (global-subword-mode 1)
 #+end_src
** Electric
This creates matching paranthesis/brackets etc.
#+begin_src emacs-lisp
  (setq electric-pair-pairs '(
                  (?\( . ?\))
                  (?\[ . ?\])
                  (?\{ . ?\})
                  (?\" . ?\")
                  (?\' . ?\')
                  ))
  (electric-pair-mode t)
#+end_src
** Buffers
Improve default emacs buffers.
*** Use ibuffer instead of switch-to-buffer
This should be the default option in the first place. 
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
  (global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
#+end_src
*** Always kill current buffer
Doing =C-x k= should always kill the current buffer by default, for more complicated buffer management I use ibuffer.
#+begin_src emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+end_src
*** Close all buffers
Sometimes I want to close all buffers to start fresh, this makes it a single command.
#+begin_src emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+end_src
** Defer loading packages for quicker startup
#+begin_src emacs-lisp
  (setq use-package-always-defer t)
#+end_src
* Org
Org was one of the main reasons why I decided to start using Emacs. I will never have to write documents in any other way. Org mode can do it all.
** Common settings
#+begin_src emacs-lisp
(setq org-ellipsis " ")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-confirm-babel-evaluate nil)
(setq org-export-with-smart-quotes t)
(setq org-src-window-setup 'current-window)
(add-hook 'org-mode-hook 'org-indent-mode)
#+end_src
** Snippets
Snippets for org mode.
*** src emacs-lisp
#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
  (add-to-list 'org-structure-template-alist
	       '("el" . "src emacs-lisp"))
#+end_src
** Org Bullets
Makes org mode bullets look nicer.
#+begin_src emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+end_src
** Syntax highlighting for HTML export
#+begin_src emacs-lisp
  (use-package htmlize
    :ensure t)
#+end_src
** Exporting options
One of the reasons that makes org so special is the ability to export files in many different formats.
*** Twitter bootstrap
#+begin_src emacs-lisp
  (use-package ox-twbs
    :ensure t)
#+end_src
* Terminal
I don't usually use the terminal inside emacs, but it is nice to have conveniently available.
** Setting default shell to bash
Emacs asks for the shell you want to use every time you launch the terminal. We can skip that by adding a default shell.
#+begin_src emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
   (ad-activate 'ansi-term)
#+end_src
** Open terminal hotkey
I use super+return to open terminal in my Window manager. It makes sense to use a similar binding for emacs terminal. 
#+begin_src emacs-lisp
(global-set-key (kbd "<M-s-return>") 'ansi-term)
#+end_src
* Navigation
Packages and improvements for navigation in emacs.
** Dired
Easier key binding to open dired.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c d") 'dired-other-window)
#+end_src
** IDO
Ido mode improves buffer switching and prompts.
*** enable ido mode
#+begin_src emacs-lisp
(setq ido-enable-flex-matching nil)
(setq ido-create-new-buffer 'always)
(setq ido-everywhere t)
#+end_src
*** ido vertical mode
#+begin_src emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init
    (ido-vertical-mode 1))
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+end_src
*** ido completing read+
Truly enables ido wherever possible.
#+begin_src emacs-lisp
  (use-package ido-completing-read+
    :ensure t
    :init
    (ido-ubiquitous-mode 1))
#+end_src
*** smex
Enhanced M-x menu.
#+begin_src emacs-lisp
  (use-package smex
    :ensure t
    :init
    (global-set-key (kbd "M-x") 'smex))
#+end_src
** Which key
Which key shows auto-completion for emacs commands.
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode))
#+end_src
** swiper
Swiper no swiping! Improves the default search functionality.
#+begin_src emacs-lisp
  (use-package swiper
      :ensure t
      :bind ("C-s" . 'swiper))
#+end_src
** avy
Avy allows easy navigation to characters in buffer.
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("M-s" . avy-goto-char))
#+end_src
** rg
Ripgrep to search for file contents. Previously I used my [[./.local/bin/ff.sh][fuzzy-finding script]] from the terminal but it is much nicer to do from inside Emacs.
#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :config
    (setq rg-group-result t)
    (setq rg-hide-command t)
    (setq rg-show-columns nil)
    (setq rg-show-header t)
    (setq rg-custom-type-aliases nil)
    (setq rg-default-alias-fallback "all")
    :bind
    (:map rg-mode-map
          ("C-n" . next-line)
          ("C-p" . previous-line)
          ("M-n" . rg-next-file)
          ("M-p" . tg-prev-file)))
#+end_src
** switch-window
Improves window switching when multiple splits are used. =C-x o=.
#+begin_src emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    :bind
    ([remap other-window] . switch-window))
#+end_src
** Follow window split
When a window is split move cursor to new split.
#+begin_src emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+end_src
** Config edit/reload shortcuts
*** Edit
#+begin_src emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.config/emacs/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+end_src
*** Reload
#+begin_src emacs-lisp
  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.config/emacs/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+end_src
** beacon
Beacon flashes the cursor when moving between buffers/windows. It helps to quickly find the current cursor position.
#+begin_src emacs-lisp
(use-package beacon
  :ensure t
  :init
  (beacon-mode 1))
#+end_src
* Text editing
Useful packages and configurations to improve editing text in emacs.
** Kills entire word
#+begin_src emacs-lisp
  (defun kill-whole-word ()
    (interactive)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "M-d") 'kill-whole-word)
#+end_src
** Copy whole line
#+begin_src emacs-lisp
  (defun copy-whole-line ()
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
  (global-set-key (kbd "C-c w") 'copy-whole-line)
#+end_src
** Sudo edit
Sometimes I want to edit files that need root permissions, this package makes it very easy. Just press a hotkey and select a file to edit as sudo.
#+begin_src emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind ("C-c s" . sudo-edit))
#+end_src
** popup kill ring
Browse kill ring.
#+begin_src emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+end_src
* General packages
Some general packages to improve how Emacs works
** auto-package-update
Automatically update and remove old packages.
#+begin_src emacs-lisp
  (use-package auto-package-update
    :defer nil
    :ensure t
    :config
    (setq auto-package-update-delete-old-versions t)
    (setq auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+end_src
** async
Use asynchronous processes when possible.
#+begin_src emacs-lisp
   (use-package async
      :ensure t
      :init
      (dired-async-mode 1))
#+end_src
* Modeline
Having a nice and useful modeline is important. I'm using the doom modeline as it is lightweight and pretty.
** doom-modeline
Install and enable doom modeline.
#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :hook
    (after-init . doom-modeline-mode))
#+end_src
** all-the-icons
Adds extra icons to doom modeline.
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src
** Show line/column number on modeline
#+begin_src emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+end_src
* Dashboard
Nice dashboard on emacs startup.
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-items '((recents . 10)))
    (setq dashboard-banner-logo-title "Miika's Emacs")
    (setq dashboard-items '((recents . 5)
                              (projects . 5))))
#+end_src
* Programming
Mostly programming related configurations and packages.
** Line numbers when programming
Having line numbers is very useful when programming.
#+begin_src emacs-lisp
  (use-package linum-relative
    :ensure t
    :config
      (setq linum-relative-current-symbol "")
      (add-hook 'prog-mode-hook 'linum-relative-mode))
#+end_src
** Default indentation
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default standard-indent 4)
  (setq c-basic-offset tab-width)
  (setq-default electric-indent-inhibit t)
  (setq-default indent-tabs-mode t)
  (setq backward-delete-char-untabify-method 'nil)
#+end_src
** Comment code
Comments/uncomments the selected region.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-;") 'comment-or-uncomment-region)
#+end_src
** yasnippet
Snippets are cool.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all)
    (add-hook 'prog-mode-hook #'yas-minor-mode))
#+end_src
** flycheck
Check syntax errors while editing.
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t)
#+end_src
** company
Autocompletion is really nice for programming and most IDEs come with it out of the box. For emacs I use company to do my autocompletion.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'company-mode)
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 4))
#+end_src
*** Change default company keybindings
#+begin_src emacs-lisp
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+end_src
** C/C++
Irony is what gives us C/C++ completion. First we install the packages and then we add a hook to enable company-mode in C/C++ buffers.
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)

  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+end_src
** Python
For python completion I'm using jedi as a backend. It follows the PEP-8 styling guide.
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)

  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+end_src
** Javascript
#+begin_src emacs-lisp
  (use-package prettier-js
    :ensure t
    :hook
    (web-mode . prettier-js-mode)
    (js2-mode-hook . prettier-js-mode))
#+end_src
** Bash
Auto-completion, snippets, syntax checking for bash.
#+begin_src emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+end_src
** web-mode
Improves HTML documents when using embed parts and blocks. I Mainly use it for Django development. 
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (setq web-mode-engines-alist
          '(("django" . "\\.html\\'")))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (setq web-mode-enable-auto-closing t))
#+end_src
** rainbow-mode
Rainbow mode colorizes color names in buffers.
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-mode)
    (rainbow-mode 1))
#+end_src
Ranbow delimiters mode colorizes matrching paranthesis. Very useful for elisp. 
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (rainbow-delimiters-mode 1))
#+end_src
** ReST
Activate snippets in ReST mode
#+begin_src emacs-lisp
  (add-hook 'rst-mode-hook 'yas-minor-mode)
#+end_src
* Git
I tend to mostly do git commands from the terminal but I'm trying to learn how to use magit instead.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+end_src
* Projectile
Projectile helps with navigating files in a project. Projectile also integrates nicely with dashboard.
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
    (projectile-mode +1))
#+end_src
* Music
Music from Emacs because why not?!
** MPD & Mingus
I've used NCMPCPP as my main frontend for MPD and got very used to how it worked. I tried finding a similar package for Emacs but none of them were quite as good. EMMS seems great and has tons of features but I don't need most of them. I ended up with Mingus which is very intuitive to use coming from NCMPCPP. 
The built in MPC client for Emacs is also okay but the playlist management on it is horrible. 
*** Mingus
Installs Mingus and sets keybindings.
#+begin_src emacs-lisp
  (use-package mingus
    :ensure t
    :bind
    ("s-m m" . mingus)
    ("s-SPC" . mingus-pause)
    ("s-," . mingus-vol-down)
    ("s-." . mingus-vol-up)
    ("s-n" . mingus-next)
    ("s-n" . mingus-prev)
    ("s-c" . mingus-clear))
#+end_src
*** MPC
Setups mpc to use the right host:port
#+begin_src emacs-lisp
  (setq mpc-host "localhost:6600")
#+end_src
*** Advanced MPD configuration
**** Start MPD daemon from emacs
#+begin_src emacs-lisp
  (defun mpd/start-music-daemon ()
    "Starts MPD daemon"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (message "MPD Started"))
  (global-set-key (kbd "s-m c") 'mpd/start-music-daemon)
#+end_src
**** Kill MPD daemon from emacs
#+begin_src emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Kills MPD daemon"
    (interactive)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed"))
  (global-set-key (kbd "s-m k") 'mpd/kill-music-daemon)
#+end_src
**** Update MPD database from emacs
#+begin_src emacs-lisp
  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated"))
  (global-set-key (kbd "s-m u") 'mpd/update-database)
#+end_src
