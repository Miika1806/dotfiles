#+STARTUP: overview
#+TITLE: Miika's Emacs
#+CREATOR: Miika Nissi
#+LANGUAGE: en
#+OPTIONS: num:nil
#+html: <p align="center"><img src="./screenshots/dashboard.png"/></p>
On Feb 19, 2021, I decided to fully jump into using Emacs as my "operating system". Since then I have been building additional features on top of the base Emacs program. My entire configuration is in this single Org-mode file so it is very portable from computer to computer.
* Installation
=git clone https://github.com/miikanissi/MiikasEmacs ~/.config/emacs=

Make sure to remove your own =~/.emacs=, =~/.emacs.d= and =~/.config/emacs= prior to cloning this configuration. When you launch emacs it will automatically download and setup all packages.
This configuration is written in Org-mode and is self documented.
** Extra dependencies
*** Fonts
I currently use IBM Plex Mono Nerd Font from [[https://github.com/ryanoasis/nerd-fonts][Nerd fonts]]. You need to make sure this font is installed for emacs to use it. I have made a simple installation script for this font in [[../../.local/bin/install_nerd_fonts_blex.sh][~/.local/bin/install_nerd_fonts_blex.sh]].
*** From package manager:
- =wmctrl=, *important!* this small program detects if WM is running. Ensures EXWM only launches when it is the WM.
- =clang=, for c/c++ completion.
- =python-virtualenv=, for python completion.
- =texlive-core=, for exporting org documents to pdf.
- =texlive-latexextra=, for exporting org documents to pdf.
- =mpd= & =mpc=, for playing music with Mingus.
- =pass= & =pass-otp=, for a password manager and secure password store for email.
- =mbsync/isync= & =mu= for email configuration.
*** From pip:
For python completion and syntax checking you need to install these from pip:
- =jedi=, for python completion and syntax checking.
- =flake8=, for python completion and syntax checking.
- =autopep8=, for python syntax checking.
- =pylint=, for python syntax checking.
- =pylint-odoo=, for python syntax checking with Odoo.
*** Emacs installation:
On the first launch of Emacs you might need to run some commands using M-x to fully install everything. Here's a list:
- =jedi:install-server=
* Theme
I don't want my eyes to bleed with the default theme.
** Gruvbox
Gruvbox is VERY easy on the eyes and I think that's the most important part of a theme. Gruvbox-theme package also comes with light/dark themes and can easily be switched to using =M-x load-theme=
#+begin_src emacs-lisp
  (use-package gruvbox-theme
    :ensure t
    :init
    (load-theme 'gruvbox-light-medium t))
#+end_src
** Font
Use BlexMono Nerd Font.
#+begin_src emacs-lisp
  (when (eq system-type 'gnu/linux)
        (add-to-list 'default-frame-alist
                     '(font . "BlexMono Nerd Font 10")))
#+end_src
* Desktop Environment
Everything regarding the WM and DE functionality is under this section. To run Emacs as a window manager you need to create the following desktop entry in =/usr/share/xsessions/= directory.
#+begin_src bash
[Desktop Entry]
Name=EXWM
Comment=Emacs as a Window Manager
Exec=emacs -mm --debug-init
Type=Application
#+end_src
*NOTE*: You can still run emacs as a standalone program on any desktop environment without any issue as long as you have =wmctrl= package installed. It checks the current Window Manager session and if one is present EXWM won't load.
** Default browser
I use Brave.
#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "brave")
#+end_src
** exwm
I first heard about exwm from my professor in college. He said how he has never met a bad programmer who did everything inside Emacs and showed us EXWM. Naturally as I wanted to become a good programmer I started looking into Emacs. It took me two years but I think I'm finally ready to start using Emacs for basically everything, including Window Management. I still use plenty of external programs of course but technically I'm running them inside Emacs.
*** Functions for EXWM
These functions are called inside the EXWM main config.
**** Rename buffer to programs class name
#+begin_src emacs-lisp
  (defun m/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))
#+end_src
**** Run program in the background
#+begin_src emacs-lisp
  (defun m/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))
#+end_src
**** Run program asynchronously
#+begin_src emacs-lisp
  (defun exwm-async-run (name)
    (interactive)
    (call-process name nil 0 nil))
#+end_src
**** Launchers
Functions to launch programs for EXWM.
#+begin_src emacs-lisp
  (defun m/launch-browser ()
    (interactive)
    (exwm-async-run "brave"))

  (defun m/screenshot ()
    (interactive)
    (exwm-async-run "~/.local/bin/screenshot.sh"))

  (use-package dmenu
    :ensure t)
#+end_src
**** Init workspace 1 on startup
#+begin_src emacs-lisp
  (defun m/exwm-init-hook ()
    (exwm-workspace-switch-create 1))
#+end_src
*** Main EXWM config
EXWM is initialized inside a function that checks if no other WM is running and then setups EXWM. This way you can use Emacs on a non EXWM session and EXWM won't interfere.
 #+begin_src emacs-lisp
   ;; only use EXWM if no other window manager is present
   (when (get-buffer "*window-manager*")
     (kill-buffer "*window-manager*"))
   (when (get-buffer "*window-manager-error*")
     (kill-buffer "*window-manager-error*"))
   (when (executable-find "wmctrl")
     (shell-command "wmctrl -m ; echo $?" "*window-manager*" "*window-manager-error*"))

   ;; if there was an error detecting the window manager, initialize EXWM
   (when (and (get-buffer "*window-manager-error*")
      (eq window-system 'x))
     ;; exwm startup goes here:
     (use-package exwm
       :ensure t
       :config

       ;; BASIC CONFIG
       (require 'exwm-config)
       ;; fringe size
       (fringe-mode 3)
       ;; emacs as a daemon, edit files from terminal using "emacsclient <filename>"
       (server-start)
       ;; fixes ido mode
       (exwm-config-ido)
       ;; init startup workspaces
       (setq exwm-workspace-number 2)
       ;; setup monitors for EXWM I have two, internal eDP-1 and external DP-2-2
       (require 'exwm-randr)
       ;; (setq exwm-randr-workspace-monitor-plist '(0 "DP-2-2"
       ;; 1 "eDP-1"))
       (add-hook 'exwm-randr-screen-change-hook
                 (lambda ()
                   (start-process-shell-command
                    "xrandr" nil "xrandr --output DP-2-2 --same-as eDP-1")))
       (exwm-randr-enable)

       ;; When window class updates, use it as a buffer name
       (add-hook 'exwm-update-class-hook #'m/exwm-update-class)
       ;; Init hook to land on workspace 1
       (add-hook 'exwm-init-hook #'m/exwm-init-hook)

       ;; GLOBAL KEYBINDINGS
       (setq exwm-input-global-keys
             '(
               ;; Reset to line mode
               ([?\s-r] . exwm-reset)
               ([?\s-k] . exwm-workspace-delete)
               ([?\s-s] . exwm-workspace-swap)

               ;; Move between windows
               ([s-left] . windmove-left)
               ([s-right] . windmove-right)
               ([s-up] . windmove-up)
               ([s-down] . windmove-down)

               ;; Programs
               ([?\s-w] . m/launch-browser)
               ([s-print] . m/screenshot)
               ([?\s-d] . dmenu)
               ))

       ;; s-<number> to switch to corresponding workspace
       (dotimes (i 10)
         (exwm-input-set-key (kbd (format "s-%d" i))
                             `(lambda ()
                                (interactive)
                                (exwm-workspace-switch-create ,i))))
       ;; simple shell launcher, dmenu backuXSp
       (exwm-input-set-key (kbd "s-&")
                           (lambda (command)
                             (interactive (list (read-shell-command "$ ")))
                             (start-process-shell-command command nil command)))

       ;; These keys should always pass through to Emacs
       (setq exwm-input-prefix-keys
             '(?\C-x
               ?\C-u
               ?\C-h
               ?\M-x
               ?\M-`
               ?\M-&
               ?\M-:))

       ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
       (exwm-input-set-simulation-keys
        '(
          ;; movement
          ([?\C-b] . left)
          ([?\M-b] . C-left)
          ([?\C-f] . right)
          ([?\M-f] . C-right)
          ([?\C-p] . up)
          ([?\C-n] . down)
          ([?\C-a] . home)
          ([?\C-e] . end)
          ([?\M-v] . prior)
          ([?\C-v] . next)
          ([?\C-d] . delete)
          ([?\C-k] . (S-end delete))
          ;; cut/paste
          ([?\C-w] . ?\C-x)
          ([?\M-w] . ?\C-c)
          ([?\C-y] . ?\C-v)
          ;; search
          ([?\C-s] . ?\C-f)))

       ;; this little bit will make sure that XF86 keys work in exwm buffers as well
       (dolist (k '(XF86AudioLowerVolume
                    XF86AudioRaiseVolume
                    XF86PowerOff
                    XF86AudioMute
                    XF86AudioPlay
                    XF86AudioStop
                    XF86AudioPrev
                    XF86AudioNext
                    XF86ScreenSaver
                    XF68Back
                    XF86Forward
                    Scroll_Lock
                    print))
         (cl-pushnew k exwm-input-prefix-keys))

       ;; runs this external script on startup to autostart some programs
       (call-process "~/.local/bin/exwm_autostart.sh" nil 0 nil)
       ;; this just enables exwm, it started automatically once everything is ready
       (exwm-enable)))
 #+end_src
* Basic Settings
These are basic default settings that enhance the UI and functionality. No external packages used here.
** UTF-8 encoding everywhere
#+begin_src emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+end_src
** Garbage collection
Allow 20MB of memory (instead of 0.76MB) before calling garbage collection. This means GC runs less often, which speeds up some operations.
#+begin_src emacs-lisp
  (setq gc-cons-threshold 20000000)
#+end_src
** No startup message
I use a replacement for the default startup menu, =dashboard= package.
#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
#+end_src
** Remove menus and scrollbar
I don't use the GUI menus so I get rid of them.
#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src
** Enable clipboard outside of Emacs
#+begin_src emacs-lisp
  (setq x-select-enable-clipboard t)
#+end_src
** Better scrolling behavior
By default emacs scrolling jumps multiple lines when you hit the bottom of the screen. This changes the default behavior to a more sane option.
#+begin_src emacs-lisp
(setq scroll-conservatively 100)
#+end_src
** No ring-bell for errors
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src
** Highlight current line
Very helpful to avoid "losing" your cursor.
#+begin_src emacs-lisp
(when window-system (global-hl-line-mode t))
#+end_src
** Show matching paranthesis
#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src
** Visual line mode
By default long lines will go off the screen, I like to have them wrap on the next line instead.
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
** Bidirectional editing
Display all paragraphs from left to right. This reduces the amount of line scans Emacs has to do. Keep the default value if working with languages that spell from right to left.
#+begin_src emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)

  (if (version<= "27.1" emacs-version)
      (setq bidi-inhibit-bpa t))
#+end_src
** No backups
I don't need backup or autosave files so I disable them. By default emacs creates backup files as =filename~= in the files directory. Better behavior would be to have a seperate directory for all backups but I don't feel the need for it.
#+begin_src emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+end_src
** Change yes-or-no to y-or-n
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Confirm before closing Emacs
Sometimes I accidentally do =C-x s=, =C-x c= from muscle memory of working on a single file with the terminal Emacs version. So I actually like having a confirmation before closing Emacs.
#+begin_src emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src
** Buffers
Improve default emacs buffers.
*** Use ibuffer instead of switch-to-buffer
This should be the default option in the first place.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
  (global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
#+end_src
*** Always kill current buffer
Doing =C-x k= should always kill the current buffer by default, for more complicated buffer management I use ibuffer.
#+begin_src emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+end_src
*** Close all buffers
Sometimes I want to close all buffers to start fresh, this makes it a single command.
#+begin_src emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+end_src
** Always follow symlinks
When opening a file, always follow symlinks.
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src
** Auto reload files on change
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src
** EWW
Emacs Web Wowser is a built in web browser for Emacs.
*** Scroll without changing point
#+begin_src emacs-lisp
  (add-hook 'eww-mode-hook 'scroll-lock-mode)
#+end_src
* Org
Org was one of the main reasons why I decided to start using Emacs. I will never have to write documents in any other way. Org mode can do it all.
** Org-plus-contrib
Have to add a new package archive for org-plus-contrib for some reason. I also remove default css and js, add default language and utf-8 etc.
#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (use-package htmlize
    :ensure t)
  (use-package org
    :ensure org-plus-contrib)
#+end_src
** Common settings
#+begin_src emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src
** Snippets
Snippets for org mode.
*** src emacs-lisp
#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
  (add-to-list 'org-structure-template-alist
	       '("el" . "src emacs-lisp"))
#+end_src
** Org Bullets
Makes org mode bullets look nicer.
#+begin_src emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+end_src
** Syntax highlighting for HTML export
#+begin_src emacs-lisp
  (use-package htmlize
    :ensure t)
#+end_src
** Exporting options
One of the reasons that makes org so special is the ability to export files in many different formats.
*** Twitter bootstrap
#+begin_src emacs-lisp
  (use-package ox-twbs
    :ensure t)
#+end_src
*** HTML export config
Miscellaneous configurations for HTML exporting.
#+begin_src emacs-lisp
  (require 'org)
  (require 'ox-html)
  (require 'ox-publish)
  (require 'ox-rss)
  (require 'htmlize)
  (setq org-export-default-language "en")
  (setq org-export-htmlize-output-type 'css)
  (setq org-html-htmlize-output-type 'css)
  (setq org-html-head-include-default-style t)
  (setq org-html-head-include-scripts t)
  (setq org-export-with-sub-superscripts nil)
  (setq org-html-doctype "html5")
  (setq org-export-with-priority t)
  (setq org-html-validation-link nil)
#+end_src
** Blog
I have previously used my own [[https://github.com/miikanissi/blogi][blog system]] written in bash to make and publish my blogs. It works fine but the only downside is I have to manually write the html for my posts. Once I got used to using org-mode I wanted to find a way to write blogs with it.
Org-publish allows me to write posts in org-mode and easily render them to html and publish on my website ([[https://miikanissi.com/][https://miikanissi.com/]]).

File structure for my website is as follows:
#+begin_src bash
  root
  ├── org
  │   ├── about.org
  │   ├── blog
  │   │   └── post1.org
  │   ├── css
  │   │   └── site.css
  │   ├── html
  │   │   ├── html_head.html
  │   │   ├── html_postamble.html
  │   │   └── html_preamble.html
  │   ├── img
  │   │   ├── favicon.ico
  │   │   └── miika.jpg
  │   ├── index.org
  │   ├── rss.org
  │   └── sitemap.org
  └── www
      ├── about.html
      ├── blog
      │   └── post1.html
      ├── css
      │   └── site.css
      ├── img
      │   ├── favicon.ico
      │   └── miika.jpg
      ├── index.html
      ├── rss.xml
      └── sitemap.html

  9 directories, 19 files
#+end_src
*** Custom functions for org-publish
**** Customize sitemap
Customizes the sitemap-format-entry to show the publishing date.
#+begin_src emacs-lisp
  (defun m/org-publish-org-sitemap (title list)
    "Sitemap generation function."
    (concat "#+TITLE: Sitemap\n\n"
            (org-list-to-subtree list)))

  (defun m/org-publish-org-sitemap-format-entry (entry style project)
    (cond ((not (directory-name-p entry))
           (let* ((date (org-publish-find-date entry project)))
             (format "%s - [[file:%s][%s]]"
                     (format-time-string "%F" date) entry
                     (org-publish-find-title entry project))))
          ((eq style 'tree)
           ;; Return only last subdir.
           (file-name-nondirectory (directory-file-name entry)))
          (t entry)))
#+end_src
**** Rss feed
Custom functions to build an RSS feed with all blog contents.
#+begin_src emacs-lisp
  (defun m/org-rss-publish-to-rss (plist filename pub-dir)
    "Publish RSS with PLIST, only when FILENAME is 'rss.org'.
  PUB-DIR is when the output will be placed."
    (if (equal "rss.org" (file-name-nondirectory filename))
        (org-rss-publish-to-rss plist filename pub-dir)))

  (defun m/format-rss-feed (title list)
    "Generate RSS feed, as a string.
  TITLE is the title of the RSS feed.  LIST is an internal
  representation for the files to include, as returned by
  `org-list-to-lisp'.  PROJECT is the current project."
    (concat "#+TITLE: " title "\n\n"
            (org-list-to-subtree list 1 '(:icount "" :istart ""))))

  (defun m/format-rss-feed-entry (entry style project)
    "Format ENTRY for the RSS feed.
  ENTRY is a file name.  STYLE is either 'list' or 'tree'.
  PROJECT is the current project."
    (cond ((not (directory-name-p entry))
           (let* ((file (org-publish--expand-file-name entry project))
                  (title (org-publish-find-title entry project))
                  (date (format-time-string "%Y-%m-%d" (org-publish-find-date entry project)))
                  (link (concat (file-name-sans-extension entry) ".html")))
             (with-temp-buffer
               (insert (format "* %s\n" title))
               (org-set-property "RSS_PERMALINK" link)
               (org-set-property "PUBDATE" date)
               (insert-file-contents file)
               (buffer-string))))
          ((eq style 'tree)
           ;; Return only last subdir.
           (file-name-nondirectory (directory-file-name entry)))
          (t entry)))
#+end_src
**** XML Sitemap for SEO
This is different from the sitemap we defined previously. Search engines use this sitemap.xml file to crawl the web for search results. We generate this from all of the html files in the project.
#+begin_src emacs-lisp
  (defun templated-html-create-sitemap-xml (output directory base-url &rest regexp)
    (let* ((rx (or regexp "\\.html")))
      (with-temp-file output
        (insert "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
  <urlset
        xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"
        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"
        xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9
              http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\">\n")
        (cl-loop for file in (directory-files-recursively directory rx)
              do (insert (format "<url>\n <loc>%s/%s</loc>\n <priority>0.5</priority>\n</url>\n"
                                 base-url (file-relative-name file directory))))
        (insert "</urlset>"))))
#+end_src
*** Project spec for miikanissi.com
This is my project settings for my website [[https://miikanissi.com/][https://miikanissi.com/]].
#+begin_src emacs-lisp
  (defun m/get-publish-project-spec ()
    "Return project settings for use with `org-publish-project-alist'."
    (let* ((website-root (file-name-as-directory
                          "~/miikanissi.com"))
           (website-org (file-name-as-directory
                         (concat website-root "org")))
           (website-www (file-name-as-directory
                         (concat website-root "www")))
           (website-org-img (file-name-as-directory
                             (concat website-org "img")))
           (website-www-img (file-name-as-directory
                             (concat website-www "img")))
           (website-org-css (file-name-as-directory
                             (concat website-org "css")))
           (website-www-css (file-name-as-directory
                             (concat website-www "css")))
           (website-org-html (file-name-as-directory
                              (concat website-org "html")))
           (website-org-blog (file-name-as-directory
                               (concat website-org "blog")))
           (get-content (lambda (x)
                          (with-temp-buffer
                            (insert-file-contents (concat website-org-html
                                                          x))
                            (buffer-string))))
           (website-html-head (funcall get-content "html_head.html"))
           (website-html-preamble (funcall get-content "html_preamble.html"))
           (website-html-postamble (funcall get-content "html_postamble.html")))
        `(("org"
           :base-directory ,website-org
           :base-extension "org"
           :recursive t
           :exclude "rss\\.org\\|sitemap\\.org"
           :publishing-directory ,website-www
           :publishing-function org-html-publish-to-html
           :author "Miika Nissi"
           :email "miika@miikanissi.com"
           :with-title t
           :description "This is my personal website: a place where you can read and learn about technology related subjects."
           :keywords "Miika Nissi, blog, resume, technology, programming"
           :section-numbers nil
           :headline-levels 4
           :language en
           :with-toc nil
           :with-date t
           :with-email t
           :with-statistics-cookies nil
           :with-todo-keywords nil
           :auto-sitemap t
           :sitemap-sort-files anti-chronologically
           :sitemap-format-entry m/org-publish-org-sitemap-format-entry
           :html-head-include-default-style nil
           :html-head-include-scripts nil
           :htmlized-source t
           :html-doctype "html5"
           :html-html5-fancy t
           :html-head ,website-html-head
           :html-preamble ,website-html-preamble
           :html-postamble ,website-html-postamble)
          ("images"
           :base-directory ,website-org-img
           :base-extension "png\\|jpg\\|gif\\|svg\\|ico"
           :recursive t
           :publishing-directory ,website-www-img
           :publishing-function org-publish-attachment)
          ("css"
           :base-directory ,website-org-css
           :base-extension "css"
           :publishing-directory ,website-www-css
           :publishing-function org-publish-attachment)
          ("rss"
           :base-directory ,website-org
           :base-extension "org"
           :exclude "rss\\.org\\|index\\.org\\|about\\.org\\|sitemap\\.org"
           :recursive t
           :publishing-directory ,website-www
           :publishing-function m/org-rss-publish-to-rss
           :title "Miika's Blog"
           :description "This feed contains blog posts from Miika Nissi. Topics ranging from lifestyle to technology."
           :author "Miika Nissi"
           :html-link-use-abs-url t
           :html-link-home "https://miikanissi.com/"
           :with-broken-link t
           :with-toc nil
           :rss-image-url "https://miikanissi.com/img/favicon.ico"
           :with-date t
           :with-author t
           :creator "Miika Nissi"
           :with-description t
           :auto-sitemap t
           :sitemap-filename "rss.org"
           :sitemap-title "Miika's blog"
           :sitemap-style list
           :sitemap-sort-files anti-chronologically
           :sitemap-function m/format-rss-feed
           :sitemap-format-entry m/format-rss-feed-entry)
          ("miikanissi.com" :components ("org" "images" "css" "rss")))))
#+end_src
*** Function to publish miikanissi.com project
The website is updated when calling =(m/publish-website)=, which only publishes newly modified files. When used with additional arguments, a full update can be forced: =(m/publish-website "miikanissi.com" t)=.
#+begin_src emacs-lisp
  (defun m/publish-website (&optional project force)
    "Publish personal website."
    (interactive)
    (unless project (setq project "miikanissi.com"))
    (let ((org-publish-project-alist (m/get-publish-project-spec))
          (org-export-date-timestamp-format "%Y-%m-%d")
          (org-todo-keywords '((sequence "TODO" "REVIEW" "|"
                                         "DONE" "DEFERRED" "ABANDONED"))))
      (org-publish-project project force))
    (templated-html-create-sitemap-xml "~/miikanissi.com/www/sitemap.xml" "~/miikanissi.com/www" "https://miikanissi.com/"))
#+end_src
* Terminal
I find that ansi-term works fine for most tasks. If you use ncurses style programs a lot then you should use an external terminal for them.
There is also an external package vterm which aims to provide a full terminal emulator inside Emacs, however it is still in an alpha stage.
** Setting default shell to bash
Emacs asks for the shell you want to use every time you launch the terminal. We can skip that by adding a default shell.
#+begin_src emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+end_src
** Open terminal hotkey
I use super+return to open terminal in my Window manager. It makes sense to use a similar binding for emacs terminal.
#+begin_src emacs-lisp
(global-set-key (kbd "<M-s-return>") 'ansi-term)
#+end_src
** Disable line highlight and beacon in terminal
#+begin_src emacs-lisp
  (add-hook 'term-mode-hook (lambda ()
                              (setq-local global-hl-line-mode nil)
                              (setq-local beacon-mode nil)))
#+end_src
** Disable running process warning for terminal
#+begin_src emacs-lisp
  (defun set-no-process-query-on-exit ()
    (let ((proc (get-buffer-process (current-buffer))))
      (when (processp proc)
        (set-process-query-on-exit-flag proc nil))))

  (add-hook 'term-exec-hook 'set-no-process-query-on-exit)
  (add-hook 'vterm-mode-hook 'set-no-process-query-on-exit)
#+end_src
** Set UTF-8 in the terminal
#+begin_src emacs-lisp
  (defun my-term-use-utf8 ()
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  (add-hook 'term-exec-hook 'my-term-use-utf8)
#+end_src
** Make URLs clickable
#+begin_src emacs-lisp
  (defun my-term-hook ()
    (goto-address-mode))

  (add-hook 'term-mode-hook 'my-term-hook)
#+end_src
** Allow pasting with C-y
#+begin_src emacs-lisp
  (defun my-term-paste (&optional string)
   (interactive)
   (process-send-string
    (get-buffer-process (current-buffer))
    (if string string (current-kill 0))))

  (defun my-term-hook ()
    (goto-address-mode)
    (define-key term-raw-map "\C-y" 'my-term-paste))
#+end_src
** Vterm
Requires Emacs27 or above. Offers a full terminal emulator inside Emacs. Based on libvterm library.
#+begin_src emacs-lisp
  (if (version<= "27.1" emacs-version)
      (use-package vterm
        :ensure t
        :config
        (setq vterm-kill-buffer-on-exit t)
        (setq vterm-shell "/bin/bash")))
#+end_src
* Navigation
Packages and improvements for navigation in emacs.
** Window rules
Rules for setting a specific layout for different windows.
#+begin_src emacs-lisp
  (setq display-buffer-alist
        '(;; bottom side window
          ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . -1)
           (window-parameters . ((mode-line-format . none))))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-height . 0.25)
           (side . bottom)
           (slot . 1)
           (window-parameters . ((mode-line-format . none))))
          ;; left side window
          ("\\*Help.*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)
#+end_src
** Subword
By default =M-f= / =M-b= treat thisIsOneWord as a single word instead. I want it to consider capitalization as a new word.
 #+begin_src emacs-lisp
   (global-subword-mode 1)
 #+end_src
** Dired
*** Human readable units
#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-alh")
#+end_src
*** Recursively copy by default
#+begin_src emacs-lisp
  (setq dired-recursive-copies 'always)
#+end_src
** IDO
Ido mode improves buffer switching and prompts.
*** enable ido mode
#+begin_src emacs-lisp
(setq ido-enable-flex-matching nil)
(setq ido-create-new-buffer 'always)
(setq ido-everywhere t)
#+end_src
*** ido vertical mode
#+begin_src emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init
    (ido-vertical-mode 1))
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+end_src
*** ido completing read+
Truly enables ido wherever possible.
#+begin_src emacs-lisp
  (use-package ido-completing-read+
    :ensure t
    :init
    (ido-ubiquitous-mode 1))
#+end_src
*** smex
Enhanced M-x menu.
#+begin_src emacs-lisp
  (use-package smex
    :ensure t
    :init
    (global-set-key (kbd "M-x") 'smex))
#+end_src
** Which key
Which key shows auto-completion for emacs commands.
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode))
#+end_src
** swiper
Swiper no swiping! Improves the default search functionality.
#+begin_src emacs-lisp
  (use-package swiper
      :ensure t
      :bind ("C-s" . 'swiper))
#+end_src
** avy
Avy allows easy navigation to characters in buffer.
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("M-s" . avy-goto-char))
#+end_src
** rg
Ripgrep to search for file contents. Previously I used my [[./.local/bin/ff.sh][fuzzy-finding script]] from the terminal but it is much nicer to do from inside Emacs.
#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :config
    (setq rg-group-result t)
    (setq rg-hide-command t)
    (setq rg-show-columns nil)
    (setq rg-show-header t)
    (setq rg-custom-type-aliases nil)
    (setq rg-default-alias-fallback "all")
    :bind
    (:map rg-mode-map
          ("C-n" . next-line)
          ("C-p" . previous-line)
          ("M-n" . rg-next-file)
          ("M-p" . tg-prev-file)))
#+end_src
** switch-window
Improves window switching when multiple splits are used. =C-x o=.
#+begin_src emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    :bind
    ([remap other-window] . switch-window))
#+end_src
** windmove
Instead of using =C-x o= to switch between windows you can also use the built in windmove functionality to move with Shift and the arrow keys.
#+begin_src emacs-lisp
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
  (setq org-support-shift-select 'always)
#+end_src
** beacon
Beacon flashes the cursor when moving between buffers/windows. It helps to quickly find the current cursor position.
#+begin_src emacs-lisp
(use-package beacon
  :ensure t
  :init
  (beacon-mode 1))
#+end_src
** Follow window split
When a window is split move cursor to new split.
#+begin_src emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+end_src
** Config edit/reload shortcuts
*** Edit
#+begin_src emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.config/emacs/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+end_src
*** Reload
#+begin_src emacs-lisp
  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.config/emacs/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+end_src
* Text editing
Useful packages and configurations to improve editing text in emacs.
** Electric
This creates matching paranthesis/brackets etc.
#+begin_src emacs-lisp
  (setq electric-pair-pairs '(
                  (?\( . ?\))
                  (?\[ . ?\])
                  (?\{ . ?\})
                  (?\" . ?\")
                  ))
  (electric-pair-mode t)
#+end_src
** Typing on highlighted text deletes it
#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src
** Kills entire word
#+begin_src emacs-lisp
  (defun kill-whole-word ()
    (interactive)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "M-d") 'kill-whole-word)
#+end_src
** Copy whole line
#+begin_src emacs-lisp
  (defun copy-whole-line ()
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
  (global-set-key (kbd "C-c w") 'copy-whole-line)
#+end_src
** Move current line up or down
#+begin_src emacs-lisp
  (defun move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (global-set-key (kbd "M-<down>") 'move-line-down)
  (global-set-key (kbd "M-<up>") 'move-line-up)
#+end_src
** Delete trailing whitespace
Delete trailing whitespace in all modes except Markdown as it uses two trailing whitespaces as a signal to create a line break.
#+begin_src emacs-lisp
  (add-hook 'before-save-hook '(lambda()
                                (when (not (or (derived-mode-p 'markdown-mode)))
                                  (delete-trailing-whitespace))))
#+end_src
** Save as sudo
Sometimes I want to edit files that need root permissions, this small script makes it very easy.
#+begin_src emacs-lisp
  (defun ph/sudo-file-name (filename)
    "Prepend '/sudo:root@`system-name`:' to FILENAME if appropriate.
  This is, when it doesn't already have a sudo-prefix."
    (if (not (or (string-prefix-p "/sudo:root@localhost:"
                                  filename)
                 (string-prefix-p (format "/sudo:root@%s:" system-name)
                                  filename)))
        (format "/sudo:root@%s:%s" system-name filename)
      filename))

  (defun ph/sudo-save-buffer ()
    "Save FILENAME with sudo if the user approves."
    (interactive)
    (when buffer-file-name
      (let ((file (ph/sudo-file-name buffer-file-name)))
        (if (yes-or-no-p (format "Save file as %s ? " file))
            (write-file file)))))

  (advice-add 'save-buffer :around
              '(lambda (fn &rest args)
                 (when (or (not (buffer-file-name))
                           (not (buffer-modified-p))
                           (file-writable-p (buffer-file-name))
                           (not (ph/sudo-save-buffer)))
                   (call-interactively fn args))))
#+end_src
** popup kill ring
Browse kill ring.
#+begin_src emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+end_src
** yasnippet
Snippets are cool.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all)
    (add-hook 'prog-mode-hook #'yas-minor-mode)
    (add-hook 'org-mode-hook #'yas-minor-mode))
#+end_src
* General packages
Some general packages to improve how Emacs works
** auto-package-update
Automatically update and remove old packages.
#+begin_src emacs-lisp
  (use-package auto-package-update
    :defer nil
    :ensure t
    :config
    (setq auto-package-update-delete-old-versions t)
    (setq auto-package-update-hide-results t)
    (auto-package-update-maybe))
#+end_src
** async
Use asynchronous processes when possible.
#+begin_src emacs-lisp
   (use-package async
      :ensure t
      :init
      (dired-async-mode 1))
#+end_src
* Modeline
I like the way powerline looks with spaceline-theme.
** powerline
Install and enable powerline.
#+begin_src emacs-lisp
  (use-package powerline
    :ensure t
    :init
    (spaceline-spacemacs-theme)
    :hook
    ('after-init-hook) . 'powerline-reset)
#+end_src
** diminish
Diminish hides minor modes from modeline.
#+begin_src emacs-lisp
  (use-package diminish
    :ensure t
    :config
    (diminish 'eldoc-mode)
    (diminish 'which-key-mode)
    (diminish 'visual-line-mode)
    (diminish 'linum-relative-mode)
    (diminish 'subword-mode)
    (diminish 'beacon-mode)
    (diminish 'irony-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'rainbow-delimiters-mode)
    (diminish 'rainbow-mode)
    (diminish 'yas-minor-mode)
    (diminish 'flycheck-mode)
    (diminish 'org-indent-mode)
    (diminish 'projectile-mode))
#+end_src
** Battery indicator
A package called fancy-battery will be used if we are in GUI emacs, otherwise the built in battery-mode will be used. Fancy battery has very odd colors if used in the tty, hence us disabling it.
#+begin_src emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
      (setq fancy-battery-show-percentage t)
      (setq battery-update-interval 30)
      (if window-system
        (fancy-battery-mode)
        (display-battery-mode)))
#+end_src
** Clock
Shows time in the statusbar in the format of 02:00PM.
#+begin_src emacs-lisp
  (setq display-time-format "%I:%M%p")
  (setq display-time-default-load-average nil)
  (display-time-mode t)
#+end_src
** Show line/column number on modeline
#+begin_src emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+end_src
* Dashboard
Nice dashboard on emacs startup.
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-banner-logo-title "Miika's Emacs")
    (setq dashboard-set-init-info t)
    (setq dashboard-items '((recents . 10)
                              (projects . 5))))
#+end_src
* Programming
Mostly programming related configurations and packages.
** Line numbers when programming
Having line numbers is very useful when programming.
#+begin_src emacs-lisp
  (use-package linum-relative
    :ensure t
    :config
      (setq linum-relative-current-symbol "")
      (add-hook 'prog-mode-hook 'linum-relative-mode))
#+end_src
** Indentation
*** Default indentation for different modes
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default standard-indent 4)
  (setq c-basic-offset tab-width)
  (setq cperl-indent-level tab-width)
  (setq-default electric-indent-inhibit t)
  (setq-default indent-tabs-mode nil)
  (setq backward-delete-char-untabify-method 'nil)
  (setq web-mode-enable-auto-closing t)
  (setq web-mode-markup-indent-offset 4)
  (setq web-mode-code-indent-offset 4)
  (setq nxml-child-indent 4 nxml-attribute-indent 4)
  (setq python-indent 4)
  (setq css-indent-offset 2)
  (setq js-indent-level 4)
#+end_src
*** Auto-indent with Return key
#+begin_src emacs-lisp
  (define-key global-map (kbd "RET") 'newline-and-indent)
#+end_src
** Comment code
Comments/uncomments the selected region.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-;") 'comment-or-uncomment-region)
#+end_src
** flycheck
Check syntax errors while editing.
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t)
#+end_src
** company
Autocompletion is really nice for programming and most IDEs come with it out of the box. For emacs I use company to do my autocompletion.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'company-mode)
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 4))
#+end_src
*** Change default company keybindings
#+begin_src emacs-lisp
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+end_src
** C/C++
Irony is what gives us C/C++ completion. First we install the packages and then we add a hook to enable company-mode in C/C++ buffers.
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)

  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+end_src
** Python
Python specific configurations.
*** python-mode
Makes sure python-mode runs as python3.
#+begin_src emacs-lisp
  (setq python-shell-interpreter "python3")
#+end_src
*** Hook yasnippet and flycheck to python mode
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)
#+end_src
*** company for python
For python completion I'm using jedi as a backend. It follows the PEP-8 styling guide.
#+begin_src emacs-lisp
  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+end_src
** Javascript
#+begin_src emacs-lisp
  (use-package prettier-js
    :ensure t
    :hook
    (web-mode . prettier-js-mode)
    (js2-mode-hook . prettier-js-mode))
#+end_src
** Bash
Auto-completion, snippets, syntax checking for bash.
#+begin_src emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+end_src
** web-mode
Improves HTML documents when using embed parts and blocks. I Mainly use it for Django development.
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (setq web-mode-engines-alist
          '(("django" . "\\.html\\'")))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev)))))
#+end_src
** rainbow-mode
Rainbow mode colorizes color names in buffers.
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-mode)
    (rainbow-mode 1))
#+end_src
Ranbow delimiters mode colorizes matrching paranthesis. Very useful for elisp.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (rainbow-delimiters-mode 1))
#+end_src
** ReST
Activate snippets in ReST mode
#+begin_src emacs-lisp
  (add-hook 'rst-mode-hook 'yas-minor-mode)
#+end_src
** Git
I tend to mostly do git commands from the terminal but I'm trying to learn how to use magit instead.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+end_src
** Projectile
Projectile helps with navigating files in a project. Projectile also integrates nicely with dashboard.
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
    (projectile-mode +1))
#+end_src
* Music
Music from Emacs because why not?!
** MPD & Mingus
I've used NCMPCPP as my main frontend for MPD and got very used to how it worked. I tried finding a similar package for Emacs but none of them were quite as good. EMMS seems great and has tons of features but I don't need most of them. I ended up with Mingus which is very intuitive to use coming from NCMPCPP.
The built in MPC client for Emacs is also okay but the playlist management on it is horrible.
*** Mingus
Installs Mingus and sets keybindings.
#+begin_src emacs-lisp
  (use-package mingus
    :ensure t
    :bind
    ("s-m m" . mingus)
    ("s-SPC" . mingus-pause)
    ("s-," . mingus-vol-down)
    ("s-." . mingus-vol-up)
    ("s-n" . mingus-next)
    ("s-p" . mingus-prev)
    ("s-c" . mingus-clear))
#+end_src
*** MPC
Setups mpc to use the right host:port
#+begin_src emacs-lisp
  (setq mpc-host "localhost:6600")
#+end_src
*** Advanced MPD configuration
**** Start MPD daemon from emacs
#+begin_src emacs-lisp
  (defun mpd/start-music-daemon ()
    "Starts MPD daemon"
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (message "MPD Started"))
  (global-set-key (kbd "s-m c") 'mpd/start-music-daemon)
#+end_src
**** Kill MPD daemon from emacs
#+begin_src emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Kills MPD daemon"
    (interactive)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed"))
  (global-set-key (kbd "s-m k") 'mpd/kill-music-daemon)
#+end_src
**** Update MPD database from emacs
#+begin_src emacs-lisp
  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated"))
  (global-set-key (kbd "s-m u") 'mpd/update-database)
#+end_src
* Instant Messaging
Instant messaging from Emacs.
** telega
Telega is a Telegram cleint for Emacs. It needs some additional configuration to make it work, check [[https://zevlg.github.io/telega.el/
   rmail:
   mhe:
   irc:
   info:
   gnus:
   docview:
   bibtex:
   bbdb:
   w3m:
   file+sys:
   file+emacs:
   ...][telega.el documentation]].
#+begin_src emacs-lisp
  (use-package telega
    :ensure t)
#+end_src
* Email
I am using mu4e as an Emacs frontend for my email. The actual syncing and sending emails is done with external programs that need to be configured. In my case I am using isync/mbsync for syncing mail, and mu for sending mail.

I also made [[https://miikanissi.com/blog/email-setup-with-mbsync-msmtp-mu4e.html][a blog post]] as a guide for setting up mbsync + mu4e for email.
** Mbsync
Here is a template configuration to follow for setting up mbsync in =~/.mbsyncrc=:
#+begin_src bash
  IMAPAccount <account>
  Host <imap.host.tld>
  Port <993>
  User <email username>
  PassCmd "pass <account>"
  SSLType IMAPS
  CertificateFile /etc/ssl/certs/ca-certificates.crt

  IMAPStore <account>-remote
  Account <account>

  MaildirStore <account>-local
  SubFolders Verbatim
  Path ~/Mail/<account>/
  Inbox ~/Mail/<account>/Inbox
  Trash ~/Mail/<account>/Trash

  Channel <account>
  Far :<account>-remote:
  Near :<account>-local:
  ;; Patterns are the names of your mail folders. You can also use * for all of your mail folders.
  Patterns INBOX "Sent Items" Drafts Trash Spam?
  SyncState *
  Create Both
  Expunge Both
  CopyArrivalDate yes
  Sync All
#+end_src
** Mu4e
Mu4e configuration.
#+begin_src emacs-lisp
  (use-package mu4e
    :defer 20
    :load-path "/usr/share/emacs/site-lisp/mue4/"
    :config
    (require 'org-mu4e)
    ;; refresh mbsync every 10 minutes
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-maildir "~/Mail")

    ;; moving messages renames files to avoid errors
    (setq mu4e-change-filenames-when-moving t)
     ;; Set up contexts for email accounts
    (setq mu4e-contexts
          `(,(make-mu4e-context
              :name "miikanissi"
              :match-func (lambda (msg) (when msg
                                          (string-prefix-p "/miikanissi" (mu4e-message-field msg :maildir))))
              :vars '(
                      (user-full-name . "Miika Nissi")
                      (user-mail-address . "miika@miikanissi.com")
                      (mu4e-sent-folder . "/miikanissi/Sent Items")
                      (mu4e-trash-folder . "/miikanissi/Trash")
                      (mu4e-drafts-folder . "/miikanissi/Drafts")
                      (mu4e-refile-folder . "/miikanissi/Archive")
                      (mu4e-sent-messages-behavior . sent)
                      ))))
    (setq mu4e-context-policy 'pick-first)
    ;; Prevent mu4e from permanently deleting trashed items
      (defun remove-nth-element (nth list)
      (if (zerop nth) (cdr list)
        (let ((last (nthcdr (1- nth) list)))
          (setcdr last (cddr last))
          list)))
    (setq mu4e-marks (remove-nth-element 5 mu4e-marks))
    (add-to-list 'mu4e-marks
                 '(trash
                   :char ("d" . "▼")
                   :prompt "dtrash"
                   :dyn-target (lambda (target msg) (mu4e-get-trash-folder msg))
                   :action (lambda (docid msg target)
                             (mu4e~proc-move docid
                                             (mu4e~mark-check-target target) "-N"))))
    ;; Display options
    (setq mu4e-view-show-images t)
    (setq mu4e-view-show-addresses 't)
     ;; Composing mail
    (setq mu4e-compose-dont-reply-to-self t)
    ;; Use mu4e for sending e-mail
    (setq mail-user-agent 'mu4e-user-agent
          message-send-mail-function 'smtpmail-send-it
          smtpmail-smtp-server "smtp.mailfence.com"
          smtpmail-smtp-service 465
          smtpmail-stream-type 'ssl)
    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t)
    (setq m/mu4e-inbox-query
          "(maildir:/miikanissi/Inbox) AND flag:unread")
    (defun m/go-to-inbox ()
      (interactive)
      (mu4e-headers-search m/mu4e-inbox-query))
    ;; start mu4e
    (mu4e t))
#+end_src
** Mu4e-alert
Shows notifications when new email arrives.
#+begin_src emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :after mu4e
    :config
    ;; Show unread emails from all inboxes
    (setq mu4e-alert-interesting-mail-query m/mu4e-inbox-query)
    ;; Show notifications for mails already notified
    (setq mu4e-alert-notify-repeated-mails nil)
    (mu4e-alert-enable-notifications)
    (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src
* Password Manager
I have been using pass, the standard UNIX password manager, for a while with Rofi integration, but I found out there is a package to integrate it with Emacs as well.
Passwords are stored in =~/.password-store= directory, for more information check [[https://www.passwordstore.org/][pass]].
#+begin_src emacs-lisp
  (use-package password-store
    :ensure t)
  (use-package password-store-otp
    :ensure t)
#+end_src
